// ==UserScript==
// @name         HandlPay Auto Transfer Bot (Infinite Loop)
// @namespace    http://tampermonkey.net/
// @version      1.8
// @description  Automate payment. PERSISTENT RUNNING: Auto-restarts after refresh/error until manually stopped.
// @author       Gemini Business
// @match        https://app.handlpay.com/pay/*
// @match        https://app.handlpay.com/payment_complete/*
// @grant        GM_setValue
// @grant        GM_getValue
// @grant        GM_addStyle
// ==/UserScript==

(function() {
    'use strict';

    // === é…ç½®åŒºåŸŸ ===
    const CONFIG = {
        AMOUNT: "5",
        WATCHDOG_TIMEOUT: 60000,
        RETRY_DELAY: 500,
        ERROR_WAIT: 1000
    };

    // === çŠ¶æ€ç®¡ç† ===
    // æ³¨æ„ï¼šisRunning çŽ°åœ¨ç›´æŽ¥ä»Žå­˜å‚¨ä¸­è¯»å–ï¼Œä¸å†åªæ˜¯å†…å­˜å˜é‡
    const STATE = {
        get isRunning() { return GM_getValue('bot_is_running', false); }, // èŽ·å–æŒä¹…åŒ–çŠ¶æ€
        set isRunning(val) { GM_setValue('bot_is_running', val); },       // ä¿å­˜æŒä¹…åŒ–çŠ¶æ€
        isPaymentPending: false,
        isWaitingForFees: false,
        count: parseInt(GM_getValue('transfer_count', 0)),
        watchdogTimer: null,
        startTime: parseInt(GM_getValue('bot_start_time', 0)) // ä¿å­˜å¼€å§‹æ—¶é—´ä»¥ä¾¿åˆ·æ–°åŽç»§ç»­è®¡æ—¶
    };

    // === é€šè®¯é¢‘é“ ===
    const botChannel = new BroadcastChannel('handlpay_bot_channel');

    // === é¡µé¢è·¯ç”±åˆ¤æ–­ ===
    const currentURL = window.location.href;

    // åœºæ™¯1: æ”¯ä»˜æˆåŠŸé¡µé¢
    if (currentURL.includes('/payment_complete/')) {
        console.log('âœ… Payment Complete Page Detected.');
        botChannel.postMessage({ type: 'PAYMENT_SUCCESS' });
        setTimeout(() => { window.close(); }, 100);
        return;
    }

    // åœºæ™¯2: æ”¯ä»˜ä¸»é¡µé¢
    if (currentURL.includes('/pay/')) {
        // é¡µé¢åŠ è½½æ—¶ï¼Œæ£€æŸ¥æ˜¯å¦å¤„äºŽâ€œå¼€å¯â€çŠ¶æ€ï¼Œå¦‚æžœæ˜¯ï¼Œè‡ªåŠ¨å¯åŠ¨
        if (STATE.isRunning) {
            console.log('ðŸ”„ Bot was running before reload. Auto-resuming...');
            initMainScript(true); // true è¡¨ç¤ºè‡ªåŠ¨å¯åŠ¨
        } else {
            initMainScript(false);
        }
    }

    function initMainScript(autoStart) {
        createUI();
        bindKeys();

        if (autoStart) {
            startBotInternal();
        }

        // ç›‘å¬æˆåŠŸä¿¡å·
        botChannel.onmessage = (event) => {
            if (event.data && event.data.type === 'PAYMENT_SUCCESS') {
                if (STATE.isRunning) {
                    console.log('ðŸ“¡ Signal received: Payment Success.');
                    updateCount();
                    unlockBot();
                }
            }
        };

        // ç›‘å¬ç„¦ç‚¹å›žå½’
        window.onfocus = () => {
            if (STATE.isRunning && STATE.isPaymentPending) {
                // ç„¦ç‚¹å›žæ¥æ—¶ï¼Œä¸ç›²ç›®è§£é”ï¼Œè€Œæ˜¯ç­‰å¾…ä¸€å°ä¼šçœ‹é¡µé¢æ˜¯å¦é‡ç½®
                setTimeout(() => { unlockBot(); }, 500);
            }
        };

        const originalOpen = window.open;
        window.open = function(...args) {
            if (STATE.isRunning) console.log('ðŸš€ New window opening detected.');
            return originalOpen.apply(this, args);
        };
    }

    function unlockBot() {
        STATE.isPaymentPending = false;
        STATE.isWaitingForFees = false;
        resetWatchdog();
        updateUI();
        requestAnimationFrame(processLoop);
    }

    // === UI åˆ›å»º ===
    function createUI() {
        const div = document.createElement('div');
        div.id = 'bot-stats-panel';
        div.innerHTML = `
            <div style="font-weight:bold; margin-bottom:4px;">ðŸ¤– Infinite Bot V1.8</div>
            <div>Status: <span id="bot-status" style="color:red;">STOPPED</span></div>
            <div>State: <span id="bot-state" style="color:#aaa;">IDLE</span></div>
            <div>Count: <span id="bot-count">${STATE.count}</span></div>
            <div>Time: <span id="bot-timer">00:00:00</span></div>
        `;
        GM_addStyle(`
            #bot-stats-panel {
                position: fixed; top: 20px; left: 20px;
                background: rgba(0, 0, 0, 0.85); color: white;
                padding: 10px 15px; border-radius: 8px; z-index: 99999;
                font-family: monospace; font-size: 12px;
                pointer-events: none; border: 1px solid #444;
                box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            }
        `);
        document.body.appendChild(div);
        updateUI(); // åˆå§‹åŒ–æ˜¾ç¤º
        if (STATE.isRunning) setInterval(updateTimer, 1000); // å¦‚æžœè‡ªåŠ¨å¯åŠ¨ï¼Œå¼€å¯è®¡æ—¶å™¨
    }

    function updateUI() {
        const statusEl = document.getElementById('bot-status');
        const countEl = document.getElementById('bot-count');
        const stateEl = document.getElementById('bot-state');

        if (statusEl) {
            statusEl.innerText = STATE.isRunning ? 'RUNNING (PERSISTENT)' : 'STOPPED';
            statusEl.style.color = STATE.isRunning ? '#0f0' : 'red';
        }
        if (countEl) countEl.innerText = STATE.count;
        if (stateEl) {
            if (!STATE.isRunning) stateEl.innerText = "IDLE";
            else if (STATE.isPaymentPending) {
                stateEl.innerText = "â³ PENDING";
                stateEl.style.color = "yellow";
            } else if (STATE.isWaitingForFees) {
                stateEl.innerText = "ðŸ” WAITING FEES";
                stateEl.style.color = "orange";
            } else {
                stateEl.innerText = "âš¡ SEARCHING";
                stateEl.style.color = "#0ff";
            }
        }
    }

    function updateTimer() {
        if (!STATE.isRunning) return;
        // å¦‚æžœæ²¡æœ‰å¼€å§‹æ—¶é—´ï¼ˆæ¯”å¦‚åˆšæ‰‹åŠ¨æ¸…é™¤ï¼‰ï¼Œé‡ç½®ä¸€ä¸‹
        if (!STATE.startTime) STATE.startTime = Date.now();

        const now = Date.now();
        const diff = now - STATE.startTime;
        const h = Math.floor(diff / 3600000).toString().padStart(2, '0');
        const m = Math.floor((diff % 3600000) / 60000).toString().padStart(2, '0');
        const s = Math.floor((diff % 60000) / 1000).toString().padStart(2, '0');
        const timerEl = document.getElementById('bot-timer');
        if (timerEl) timerEl.innerText = `${h}:${m}:${s}`;
    }

    function updateCount() {
        STATE.count++;
        GM_setValue('transfer_count', STATE.count);
        updateUI();
    }

    function bindKeys() {
        document.addEventListener('keydown', (e) => {
            if (e.altKey && e.code === 'KeyS') {
                e.preventDefault();
                toggleBot();
            }
        });
    }

    // å†…éƒ¨å¯åŠ¨å‡½æ•°
    function startBotInternal() {
        if (!STATE.startTime) {
            STATE.startTime = Date.now();
            GM_setValue('bot_start_time', STATE.startTime);
        }
        STATE.isPaymentPending = false;
        STATE.isWaitingForFees = false;
        setInterval(updateTimer, 1000);
        resetWatchdog();
        processLoop();
        updateUI();
    }

    function toggleBot() {
        // åˆ‡æ¢çŠ¶æ€
        const newState = !STATE.isRunning;
        STATE.isRunning = newState;

        if (newState) {
            // æ‰‹åŠ¨å¼€å¯ï¼Œé‡ç½®å¼€å§‹æ—¶é—´
            STATE.startTime = Date.now();
            GM_setValue('bot_start_time', STATE.startTime);
            startBotInternal();
        } else {
            // æ‰‹åŠ¨åœæ­¢
            clearTimeout(STATE.watchdogTimer);
            STATE.isPaymentPending = false;
            location.reload(); // åœæ­¢æ—¶åˆ·æ–°ä¸€ä¸‹æ¸…ç†çŠ¶æ€ï¼Œæ¯”è¾ƒå¹²å‡€
        }
        updateUI();
    }

    function resetWatchdog() {
        if (STATE.watchdogTimer) clearTimeout(STATE.watchdogTimer);
        if (!STATE.isRunning) return;
        STATE.watchdogTimer = setTimeout(() => {
            console.warn('Watchdog Timeout. Refreshing to restart...');
            location.reload();
        }, CONFIG.WATCHDOG_TIMEOUT);
    }

    // === é”™è¯¯å¤„ç† ===
    async function checkAndHandleError() {
        const okBtns = Array.from(document.querySelectorAll('button.tm-button.black.narrow.horizontal'));
        const okBtn = okBtns.find(btn => btn.textContent.trim() === 'Ok');

        if (okBtn) {
            const container = okBtn.closest('div');
            // ç®€å•æ”¾å®½æ£€æŸ¥æ¡ä»¶ï¼Œåªè¦æ˜¯è¿™ä¸ªæŒ‰é’®ç»“æž„ï¼Œå¤§æ¦‚çŽ‡å°±æ˜¯æŠ¥é”™
            if (container) {
                console.log('âš ï¸ Error Popup detected. Clicking OK...');
                okBtn.click();

                // ç‚¹å‡»OKåŽï¼Œå¼ºåˆ¶è§£é”ï¼Œè®©processLoopä¾é é¡µé¢å…ƒç´ æ¥å†³å®šä¸‹ä¸€æ­¥
                STATE.isPaymentPending = false;
                STATE.isWaitingForFees = false;
                updateUI();
                await sleep(CONFIG.ERROR_WAIT);
                return true;
            }
        }
        return false;
    }

    // === è´¹ç”¨åŠ è½½æ£€æŸ¥ ===
    function areFeesLoaded() {
        const feeLabels = Array.from(document.querySelectorAll('span'));
        const feeLabel = feeLabels.find(el => el.textContent.includes('Network fees'));
        if (!feeLabel) return true;
        const wrapper = feeLabel.closest('div').parentElement;
        if (wrapper) {
            const text = wrapper.innerText;
            if (text.includes('USDC')) return true;
            else return false;
        }
        return true;
    }

    // === æ ¸å¿ƒï¼šæ™ºèƒ½å¾ªçŽ¯ ===
    async function processLoop() {
        if (!STATE.isRunning) return;

        // 1. é”™è¯¯æ£€æµ‹ (æœ€é«˜ä¼˜å…ˆçº§)
        if (await checkAndHandleError()) {
             requestAnimationFrame(processLoop);
             return;
        }

        try {
            // === æ™ºèƒ½å¤ä½æ£€æŸ¥ (ä½ è¦æ±‚çš„é€»è¾‘) ===
            // æ— è®ºå½“å‰è„šæœ¬å¤„äºŽä»€ä¹ˆçŠ¶æ€ï¼ˆPendingä¹Ÿå¥½ï¼ŒWaitingä¹Ÿå¥½ï¼‰
            // åªè¦é¡µé¢ä¸Šå‡ºçŽ°äº†åˆå§‹çš„â€œé‡‘é¢è¾“å…¥æ¡†â€ï¼Œå°±æ„å‘³ç€é¡µé¢å·²ç»å›žåˆ°äº†èµ·ç‚¹ã€‚
            // æ­¤æ—¶å¿…é¡»å¼ºåˆ¶å¤ä½æ‰€æœ‰é”ï¼Œå¼€å§‹æ–°ä¸€è½®å¡«è¡¨ã€‚
            const input = document.querySelector('input[id*=":r3:"]');

            if (input && !input.disabled) {
                // å¦‚æžœå½“å‰è¢«é”ä½äº†ï¼Œè¯´æ˜ŽçŠ¶æ€ä¸ä¸€è‡´ï¼ˆæ¯”å¦‚æŠ¥é”™åŽé¡µé¢é‡ç½®äº†ï¼Œä½†é”æ²¡å¼€ï¼‰
                if (STATE.isPaymentPending || STATE.isWaitingForFees) {
                    console.log('ðŸ”„ Detected Start Screen while Locked. Force Resetting State.');
                    STATE.isPaymentPending = false;
                    STATE.isWaitingForFees = false;
                    updateUI();
                }

                // æ‰§è¡Œç¬¬ä¸€æ­¥ï¼šå¡«é‡‘é¢
                if (!input.value || input.value !== CONFIG.AMOUNT) {
                    console.log('ðŸ“ Step 1: Input Amount');
                    fillReactInput(input, CONFIG.AMOUNT);
                    await sleep(300);
                }
            }

            // å¦‚æžœå¤„äºŽ Pending çŠ¶æ€ä¸”æ²¡æœ‰å›žåˆ°èµ·ç‚¹ï¼Œåˆ™è·³è¿‡åŽç»­æ­¥éª¤ï¼ˆç­‰å¾…ä¸­ï¼‰
            if (STATE.isPaymentPending) {
                requestAnimationFrame(processLoop);
                return;
            }

            // --- æ­¥éª¤ 2: Select method ---
            const nextBtn = document.querySelector('button.tm-button.black');
            if (nextBtn && !nextBtn.disabled && nextBtn.textContent.includes('Select method')) {
                // åŒé‡ç¡®è®¤ï¼šåªæœ‰åœ¨è¾“å…¥äº†æ­£ç¡®é‡‘é¢åŽæ‰ç‚¹å‡»
                if (input && input.value === CONFIG.AMOUNT) {
                    nextBtn.click();
                    await sleep(500);
                }
            }

            // --- æ­¥éª¤ 3: ç¡®ä¿ Crypto è¢«é€‰ä¸­ ---
            const cryptoRadio = document.querySelector('input[name="payment-type"]');
            if (cryptoRadio && !cryptoRadio.checked) {
                 cryptoRadio.click();
                 await sleep(300);
            }

            // --- æ­¥éª¤ 4: Pay with crypto ---
            const payWithCryptoBtn = document.querySelector('button.tm-button.black.vertical');
            if (payWithCryptoBtn) {
                payWithCryptoBtn.click();
                await sleep(1000);
            }

            // --- æ­¥éª¤ 5: æœ€ç»ˆ Pay æŒ‰é’® ---
            const finalPayBtn = Array.from(document.querySelectorAll('button.tm-button.black'))
                .find(btn => btn.textContent.trim() === 'Pay');

            if (finalPayBtn) {
                // è´¹ç”¨åŠ è½½æ£€æŸ¥
                if (!areFeesLoaded()) {
                    if (!STATE.isWaitingForFees) {
                        STATE.isWaitingForFees = true;
                        updateUI();
                    }
                    requestAnimationFrame(processLoop);
                    return;
                }

                // æŒ‰é’®å¯ç”¨æ€§æ£€æŸ¥
                if (finalPayBtn.disabled) {
                     requestAnimationFrame(processLoop);
                     return;
                }

                STATE.isWaitingForFees = false;

                // æ»šåŠ¨å¹¶ç‚¹å‡»
                finalPayBtn.scrollIntoView({block: "center", inline: "nearest"});

                console.log('ðŸ‘† Clicking Final Pay...');
                STATE.isPaymentPending = true;
                updateUI();

                finalPayBtn.click();
            }

        } catch (e) {
            console.error(e);
        }

        if (STATE.isRunning) {
            requestAnimationFrame(processLoop);
        }
    }

    // === è¾…åŠ©å‡½æ•° ===
    function fillReactInput(element, value) {
        const lastValue = element.value;
        element.value = value;
        const event = new Event('input', { bubbles: true });
        const tracker = element._valueTracker;
        if (tracker) tracker.setValue(lastValue);
        element.dispatchEvent(event);
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

})();
